<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>GPU-Accelerated Data-Driven Bayesian Uncertainty Quantification with Koopman Operators · SciMLExpectations.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://SciMLExpectations.sciml.ai/stable/tutorials/gpu_bayesian/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SciMLExpectations.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../introduction/">An Introduction to Expectations via SciMLExpectations.jl</a></li><li><a class="tocitem" href="../optimization_under_uncertainty/">Optimization Under Uncertainty with SciMLExpectations.jl</a></li><li class="is-active"><a class="tocitem" href>GPU-Accelerated Data-Driven Bayesian Uncertainty Quantification with Koopman Operators</a><ul class="internal"><li><a class="tocitem" href="#Bayesian-Parameter-Estimation-with-Uncertainty"><span>Bayesian Parameter Estimation with Uncertainty</span></a></li><li><a class="tocitem" href="#Evaluating-Model-Hypotheses-with-the-Koopman-Expectation"><span>Evaluating Model Hypotheses with the Koopman Expectation</span></a></li></ul></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/problem/">ExpectationProblem</a></li><li><a class="tocitem" href="../../manual/solve/">Solving Expectation Problems</a></li><li><a class="tocitem" href="../../manual/algorithms/">Expectation Algorithms</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>GPU-Accelerated Data-Driven Bayesian Uncertainty Quantification with Koopman Operators</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>GPU-Accelerated Data-Driven Bayesian Uncertainty Quantification with Koopman Operators</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/SciMLExpectations.jl/blob/master/docs/src/tutorials/gpu_bayesian.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="GPU-Accelerated-Data-Driven-Bayesian-Uncertainty-Quantification-with-Koopman-Operators"><a class="docs-heading-anchor" href="#GPU-Accelerated-Data-Driven-Bayesian-Uncertainty-Quantification-with-Koopman-Operators">GPU-Accelerated Data-Driven Bayesian Uncertainty Quantification with Koopman Operators</a><a id="GPU-Accelerated-Data-Driven-Bayesian-Uncertainty-Quantification-with-Koopman-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#GPU-Accelerated-Data-Driven-Bayesian-Uncertainty-Quantification-with-Koopman-Operators" title="Permalink"></a></h1><p>What if you have data and a general model and would like to evaluate the probability that the fitted model outcomes would have had a given behavior? The purpose of this tutorial is to demonstrate a fast workflow for doing exactly this. It composes together a few different pieces of the SciML ecosystem:</p><ol><li>Parameter estimation with uncertainty with Bayesian differential equations by integrating the differentiable differential equation solvers with the <a href="https://turing.ml/dev/">Turing.jl library</a>.</li><li>Fast calculation of probabilistic estimates of differential equation solutions with parametric uncertainty using the Koopman expectation.</li><li>GPU-acceleration of batched differential equation solves.</li></ol><p>Let&#39;s dive right in.</p><h2 id="Bayesian-Parameter-Estimation-with-Uncertainty"><a class="docs-heading-anchor" href="#Bayesian-Parameter-Estimation-with-Uncertainty">Bayesian Parameter Estimation with Uncertainty</a><a id="Bayesian-Parameter-Estimation-with-Uncertainty-1"></a><a class="docs-heading-anchor-permalink" href="#Bayesian-Parameter-Estimation-with-Uncertainty" title="Permalink"></a></h2><p>Let&#39;s start by importing all of the necessary libraries:</p><pre><code class="language-julia hljs">using Turing, Distributions, DifferentialEquations
using MCMCChains, Plots, StatsPlots
using Random
using SciMLExpectations
using KernelDensity, SciMLExpectations
using Cuba, DiffEqGPU

Random.seed!(1);</code></pre><p>For this tutorial we will use the Lotka-Volterra equation:</p><pre><code class="language-julia hljs">function lotka_volterra(du,u,p,t)
  @inbounds begin
      x = u[1]
      y = u[2]
      α = p[1]
      β = p[2]
      γ = p[3]
      δ = p[4]
      du[1] = (α - β*y)*x
      du[2] = (δ*x - γ)*y
  end
end
p = [1.5, 1.0, 3.0, 1.0]
u0 = [1.0,1.0]
prob1 = ODEProblem(lotka_volterra,u0,(0.0,10.0),p)
sol = solve(prob1,Tsit5())
plot(sol)</code></pre><p>From the Lotka-Volterra equation we will generate a dataset with known parameters:</p><pre><code class="language-julia hljs">sol1 = solve(prob1,Tsit5(),saveat=0.1)</code></pre><p>Now let&#39;s assume our dataset should have noise. We can add this noise in and plot the noisy data against the generating set:</p><pre><code class="language-julia hljs">odedata = Array(sol1) + 0.8 * randn(size(Array(sol1)))
plot(sol1, alpha = 0.3, legend = false); scatter!(sol1.t, odedata&#39;)</code></pre><p>Now let&#39;s assume that all we know is the data <code>odedata</code> and the model form. What we want to do is use the data to inform us of the parameters, but also get a probabilistic sense of the uncertainty around our parameter estimate. This is done via Bayesian estimation. For a full look at Bayesian estimation of differential equations, look at the <a href="https://turing.ml/dev/tutorials/10-bayesiandiffeq/">Bayesian differential equation</a> tutorial from Turing.jl.</p><p>Following that tutorial, we choose a set of priors and perform <code>NUTS</code> sampling to arrive at the MCMC chain:</p><pre><code class="language-julia hljs">Turing.setadbackend(:forwarddiff)

@model function fitlv(data, prob1)
    σ ~ InverseGamma(2, 3) # ~ is the tilde character
    α ~ truncated(Normal(1.5,0.5),1.0,2.0)
    β ~ truncated(Normal(1.2,0.5),0.5,1.5)
    γ ~ truncated(Normal(3.0,0.5),2,4)
    δ ~ truncated(Normal(1.0,0.5),0.5,1.5)

    p = [α,β,γ,δ]
    prob = remake(prob1, p=p)
    predicted = solve(prob,Tsit5(),saveat=0.1)

    for i = 1:length(predicted)
        data[:,i] ~ MvNormal(predicted[i], σ)
    end
end

model = fitlv(odedata, prob1)

# This next command runs 3 independent chains without using multithreading.
chain = mapreduce(c -&gt; sample(model, NUTS(.45),1000), chainscat, 1:3)</code></pre><p>This chain gives a discrete approximation to the probability distribution of our desired quantites. We can plot the chains to see this distributions in action:</p><pre><code class="language-julia hljs">plot(chain)</code></pre><p>Great! From our data we have arrived at a probability distribution for the our parameter values.</p><h2 id="Evaluating-Model-Hypotheses-with-the-Koopman-Expectation"><a class="docs-heading-anchor" href="#Evaluating-Model-Hypotheses-with-the-Koopman-Expectation">Evaluating Model Hypotheses with the Koopman Expectation</a><a id="Evaluating-Model-Hypotheses-with-the-Koopman-Expectation-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluating-Model-Hypotheses-with-the-Koopman-Expectation" title="Permalink"></a></h2><p>Now let&#39;s try and ask a question: what is the expected value of <code>x</code> (the first term in the differential equation) at time <code>t=10</code> given the known uncertainties in our parameters? This is a good tutorial question because all other probabilistic statements can be phrased similarly. Asking a question like, &quot;what is the probability that <code>x(T) &gt; 1</code> at the final time <code>T</code>?&quot;, can similarly be phrased as an expected value (probability statements are expected values of characteristic functions which are 1 if true 0 if false). So in general, the kinds of questions we want to ask and answer are expectations about the solutions of the differential equation.</p><p>The trivial to solve this problem is to sample 100,000 sets of parameters from our parameter distribution given by the Bayesian estimation, solve the ODE 100,000 times, and then take the average. But is 100,000 ODE solves enough? Well it&#39;s hard to tell, and even then, the convergence of this approach is slow. This is the Monte Carlo approach and it converges to the correct answer by <code>sqrt(N)</code>. Slow.</p><p>However, the <a href="https://arxiv.org/abs/2008.08737">Koopman expectation</a> can converge with much fewer points, allowing the use of higher order quadrature methods to converge exponentially faster in many cases. To use the Koopman expectation functionality provided by <a href="https://github.com/SciML/SciMLExpectations.jl">SciMLExpectations.jl</a>, we first need to define our observable function <code>g</code>. This function designates the thing about the solution we wish to calculate the expectation of. Thus for our question &quot;what is the expected value of <code>x</code>at time <code>t=10</code>?&quot;, we would simply use:</p><pre><code class="language-julia hljs">function g(sol)
    sol[1,end]
end</code></pre><p>Now we need to use the <code>expectation</code> call, where we need to provide our initial condition and parameters as probability distirbutions. For this case, we will use the same constant <code>u0</code> as before. But, let&#39;s turn our Bayesian MCMC chains into distributions through <a href="https://github.com/JuliaStats/KernelDensity.jl">kernel density estimation</a> (the plots of the distribution above are just KDE plots!).</p><pre><code class="language-julia hljs">p_kde = [kde(vec(Array(chain[:α]))),kde(vec(Array(chain[:β]))),
         kde(vec(Array(chain[:γ]))),kde(vec(Array(chain[:δ])))]</code></pre><p>Now that we have our observable and our uncertainty distributions, let&#39;s calculate the expected value:</p><pre><code class="language-julia hljs">expect = expectation(g, prob1, u0, p_kde, Koopman(), Tsit5(), quadalg = CubaCuhre())</code></pre><p>Note how that gives the expectation and a residual for the error bound!</p><pre><code class="language-julia hljs">expect.resid</code></pre><h3 id="GPU-Accelerated-Expectations"><a class="docs-heading-anchor" href="#GPU-Accelerated-Expectations">GPU-Accelerated Expectations</a><a id="GPU-Accelerated-Expectations-1"></a><a class="docs-heading-anchor-permalink" href="#GPU-Accelerated-Expectations" title="Permalink"></a></h3><p>Are we done? No, we need to add some GPUs! As mentioned earlier, probability calculations can take quite a bit of ODE solves, so let&#39;s parallelize across the parameters. <a href="https://github.com/SciML/DiffEqGPU.jl">DiffEqGPU.jl</a> allows you to GPU-parallelize across parameters by using the <a href="https://diffeq.sciml.ai/stable/features/ensemble/">Ensemble interface</a>. Note that you do not have to do any of the heavy lifting: all of the conversion to GPU kernels is done automaticaly by simply specifying <code>EnsembleGPUArray</code> as the ensembling method. For example:</p><pre><code class="language-julia hljs">function lotka_volterra(du,u,p,t)
  @inbounds begin
      x = u[1]
      y = u[2]
      α = p[1]
      β = p[2]
      γ = p[3]
      δ = p[4]
      du[1] = (α - β*y)*x
      du[2] = (δ*x - γ)*y
  end
end
p = [1.5, 1.0, 3.0, 1.0]
u0 = [1.0,1.0]
prob = ODEProblem(lotka_volterra,u0,(0.0,10.0),p)
prob_func = (prob,i,repeat) -&gt; remake(prob,p=rand(Float64,4).*p)
monteprob = EnsembleProblem(prob, prob_func = prob_func, safetycopy=false)
@time sol = solve(monteprob,Tsit5(),EnsembleGPUArray(),trajectories=10_000,saveat=1.0f0)</code></pre><p>Let&#39;s now use this in the ensembling method. We need to specify a <code>batch</code> for the number of ODEs solved at the same time, and pass in our enembling method. The following is a GPU-accelerated uncertainty quanitified estimate of the expectation of the solution:</p><pre><code class="language-julia hljs">expectation(g, prob1, u0, p_kde, Koopman(), Tsit5(), EnsembleGPUArray(), batch=100, quadalg = CubaCuhre())</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../optimization_under_uncertainty/">« Optimization Under Uncertainty with SciMLExpectations.jl</a><a class="docs-footer-nextpage" href="../../manual/problem/">ExpectationProblem »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Sunday 21 August 2022 09:18">Sunday 21 August 2022</span>. Using Julia version 1.8.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
