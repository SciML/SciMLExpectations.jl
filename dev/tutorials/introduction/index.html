<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>An Introduction to Expectations via SciMLExpectations.jl · SciMLExpectations.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://SciMLExpectations.sciml.ai/stable/tutorials/introduction/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SciMLExpectations.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>An Introduction to Expectations via SciMLExpectations.jl</a><ul class="internal"><li><a class="tocitem" href="#System-Model"><span>System Model</span></a></li><li><a class="tocitem" href="#Vector-Valued-Functions"><span>Vector-Valued Functions</span></a></li><li><a class="tocitem" href="#Higher-Order-Moments"><span>Higher-Order Moments</span></a></li><li><a class="tocitem" href="#Batch-Mode"><span>Batch-Mode</span></a></li></ul></li><li><a class="tocitem" href="../optimization_under_uncertainty/">Optimization Under Uncertainty with SciMLExpectations.jl</a></li><li><a class="tocitem" href="../gpu_bayesian/">GPU-Accelerated Data-Driven Bayesian Uncertainty Quantification with Koopman Operators</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/problem/">ExpectationProblem</a></li><li><a class="tocitem" href="../../manual/solve/">Solving Expectation Problems</a></li><li><a class="tocitem" href="../../manual/algorithms/">Expectation Algorithms</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>An Introduction to Expectations via SciMLExpectations.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>An Introduction to Expectations via SciMLExpectations.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/SciMLExpectations.jl/blob/master/docs/src/tutorials/introduction.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="An-Introduction-to-Expectations-via-SciMLExpectations.jl"><a class="docs-heading-anchor" href="#An-Introduction-to-Expectations-via-SciMLExpectations.jl">An Introduction to Expectations via SciMLExpectations.jl</a><a id="An-Introduction-to-Expectations-via-SciMLExpectations.jl-1"></a><a class="docs-heading-anchor-permalink" href="#An-Introduction-to-Expectations-via-SciMLExpectations.jl" title="Permalink"></a></h1><h2 id="System-Model"><a class="docs-heading-anchor" href="#System-Model">System Model</a><a id="System-Model-1"></a><a class="docs-heading-anchor-permalink" href="#System-Model" title="Permalink"></a></h2><p>First, lets consider the following linear model.</p><p class="math-container">\[u&#39; = p u\]</p><pre><code class="language-julia hljs">f(u,p,t) = p.*u</code></pre><p>We then wish to solve this model on the timespan <code>t=0.0</code> to <code>t=10.0</code>, with an intial condition <code>u0=10.0</code> and parameter <code>p=-0.3</code>. We can then setup the differential equations, solve, and plot as follows</p><pre><code class="language-julia hljs">using DifferentialEquations, Plots
u0 = [10.0]
p = [-0.3]
tspan = (0.0,10.0)
prob = ODEProblem(f,u0,tspan,p)
sol = solve(prob)
plot(sol)
ylims!(0.0,10.0)</code></pre><p>However, what if we wish to consider a random initial condition? Assume <code>u0</code> is distributed uniformly from <code>-10.0</code> to <code>10.0</code>, i.e.,</p><pre><code class="language-julia hljs">using Distributions
u0_dist = [Uniform(-10.0,10.0)]</code></pre><p>We can then run a Monte Carlo simulation of 100,000 trajectories by solving an <code>EnsembleProblem</code>.</p><pre><code class="language-julia hljs">prob_func(prob,i,repeat) = remake(prob, u0 = rand.(u0_dist))
ensemble_prob = EnsembleProblem(prob,prob_func=prob_func)

ensemblesol = solve(ensemble_prob,Tsit5(),EnsembleThreads(),trajectories=100000)</code></pre><p>Plotting the first 250 trajectories produces</p><pre><code class="language-julia hljs">plot(ensemblesol, vars = (0,1), lw=1,alpha=0.1, label=nothing, idxs = 1:250)</code></pre><p>Given the ensemble solution, we can then compute the expectation of a function <span>$g\left(\cdot\right)$</span> of the system state <code>u</code> at any time in the timespan, e.g. the state itself at <code>t=4.0</code> as</p><pre><code class="language-julia hljs">g(sol) = sol(4.0)
mean([g(sol) for sol in ensemblesol])</code></pre><p>Alternatively, SciMLExpectations.jl offers a convenient interface for this type of calculation, <code>expectation()</code>.</p><pre><code class="language-julia hljs">using SciMLExpectations
expectation(g, prob, u0_dist, p, MonteCarlo(), Tsit5(); trajectories=100000)</code></pre><p><code>expectation()</code> takes the function of interest <span>$g$</span>, an <code>ODEProblem</code>, the initial conditions and parameters, and an <code>AbstractExpectationAlgorithm</code>. Here we use <code>MonteCarlo()</code> to use the Monte Carlo algorithm. Note that the initial conditions and parameters can be arrays that freely mix numeric and continuous distribution types from Distributions.jl. Recall, that <code>u0_dist = [Uniform(-10.0,10.0)]</code>, while <code>p = [-0.3]</code>. From this specification, the expectation is solved as</p><p class="math-container">\[\mathbb{E}\left[g\left(X\right)\vert X\sim Pf\right]\]</p><p>where <span>$Pf$</span> is the &quot;push-forward&quot; density of the initial joint pdf <span>$f$</span> on initial conditions and parameters.</p><p>Alternatively, we could solve the same problem using the <code>Koopman()</code> algorithm.</p><pre><code class="language-julia hljs">expectation(g, prob, u0_dist, p, Koopman(), Tsit5())</code></pre><p>Being that this system is linear, we can analytically compute the solution as a deterministic ODE with its initial condition set to the expectation of the initial condition, i.e.,</p><p class="math-container">\[e^{pt}\mathbb{E}\left[u_0\right]\]</p><pre><code class="language-julia hljs">exp(p[1]*4.0)*mean(u0_dist[1])</code></pre><p>We see that for this case the <code>Koopman()</code> algorithm produces a more accurate solution than <code>MonteCarlo()</code>. Not only is it more accurate, it is also much faster</p><pre><code class="language-julia hljs">@time expectation(g, prob, u0_dist, p, MonteCarlo(), Tsit5(); trajectories=100000)</code></pre><pre><code class="language-julia hljs">@time expectation(g, prob, u0_dist, p, Koopman(), Tsit5())</code></pre><p>Changing the distribution, we arrive at</p><pre><code class="language-julia hljs">u0_dist = [Uniform(0.0,10.0)]
@time expectation(g, prob, u0_dist, p, MonteCarlo(), Tsit5(); trajectories=100_000)</code></pre><p>and</p><pre><code class="language-julia hljs">@time expectation(g, prob, u0_dist, p, Koopman(), Tsit5())[1]</code></pre><p>where the analytical solution is</p><pre><code class="language-julia hljs">exp(p[1]*4.0)*mean(u0_dist[1])</code></pre><p>Note that the <code>Koopman()</code> algorithm doesn&#39;t currently support infinite or semi-infinite integration domains, where the integration domain is determined by the extrema of the given distributions. So, trying to using a <code>Normal</code> distribution will produce <code>NaN</code></p><pre><code class="language-julia hljs">u0_dist = [Normal(3.0,2.0)]
expectation(g, prob, u0_dist, p, Koopman(), Tsit5())</code></pre><p>Here, the analytical solution is</p><pre><code class="language-julia hljs">exp(p[1]*4.0)*mean(u0_dist[1])</code></pre><p>Using a truncated distribution will alleviate this problem. However, there is another gotcha. If a large majority of the probability mass of the distribution exists in a small region in the support, then the adaptive methods used to solve the expectation can &quot;miss&quot; the non-zero portions of the distribution and errantly return 0.0.</p><pre><code class="language-julia hljs">u0_dist = [truncated(Normal(3.0,2.0),-1000,1000)]
expectation(g, prob, u0_dist, p, Koopman(), Tsit5())</code></pre><p>whereas truncating at <span>$\pm 4\sigma$</span> produces the correct result</p><pre><code class="language-julia hljs">u0_dist = [truncated(Normal(3.0,2.0),-5,11)]
expectation(g, prob, u0_dist, p, Koopman(), Tsit5())</code></pre><p>If a large truncation is required, it is best practice to center the distribution on the truncated interval. This is because many of the underlying quadrature algorithms use the center of the interval as an evaluation point.</p><pre><code class="language-julia hljs">u0_dist = [truncated(Normal(3.0,2.0),3-1000,3+1000)]
expectation(g, prob, u0_dist, p, Koopman(), Tsit5())</code></pre><h2 id="Vector-Valued-Functions"><a class="docs-heading-anchor" href="#Vector-Valued-Functions">Vector-Valued Functions</a><a id="Vector-Valued-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Vector-Valued-Functions" title="Permalink"></a></h2><p><code>expectation()</code> can also handle vector-valued functions. Simply pass the vector-valued function and set the <code>nout</code> kwarg to the length of the vector the function returns.</p><p>Here, we demonstrate this by computing the expectation of <code>u</code> at <code>t=4.0s</code> and <code>t=6.0s</code></p><pre><code class="language-julia hljs">g(sol) = [sol(4.0)[1], sol(6.0)[1]]
expectation(g, prob, u0_dist, p, Koopman(), Tsit5(); nout = 2)</code></pre><p>with analytical solution</p><pre><code class="language-julia hljs">exp.(p.*[4.0,6.0])*mean(u0_dist[1])</code></pre><p>this can be used to compute the expectation at a range of times simultaneously</p><pre><code class="language-julia hljs">saveat = tspan[1]:.5:tspan[2]
g(sol) = Matrix(sol)
mean_koop = expectation(g, prob, u0_dist, p, Koopman(), Tsit5(); nout = length(saveat), saveat=saveat)</code></pre><p>We can then plot these values along with the analytical solution</p><pre><code class="language-julia hljs">plot(t-&gt;exp(p[1]*t)*mean(u0_dist[1]),tspan..., xlabel=&quot;t&quot;, label=&quot;analytical&quot;)
scatter!(collect(saveat),mean_koop.u[:],marker=:o, label=nothing)</code></pre><h3 id="Benefits-of-Using-Vector-Valued-Functions"><a class="docs-heading-anchor" href="#Benefits-of-Using-Vector-Valued-Functions">Benefits of Using Vector-Valued Functions</a><a id="Benefits-of-Using-Vector-Valued-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Benefits-of-Using-Vector-Valued-Functions" title="Permalink"></a></h3><p>In the above examples we used vector-valued expectation calculations to compute the various expectations required. Alternatively, one could simply compute multiple scalar-valued expectations. However, in most cases it is more efficient to use the vector-valued form. This is especially true when the ODE to be solved is computationally expensive.</p><p>To demonstrate this, lets compute the expectation of <span>$x$</span>, <span>$x^2$</span>, and <span>$x^3$</span> using both approaches while counting the number of times <code>g()</code> is evaluated. This is the same as the number of simulation runs required to arrive at the solution. First, consider the scalar-valued approach. Here, we follow the same method as before, but we add a counter to our function evaluation that stores the number of function calls for each expectation calculation to an array.</p><pre><code class="language-julia hljs">function g(sol, power, counter)
    counter[power] = counter[power] + 1
    sol(4.0)[1]^power
end

counters = [0,0,0]
x_koop = expectation(s-&gt;g(s,1,counters), prob, u0_dist, p, Koopman(), Tsit5())
x2_koop = expectation(s-&gt;g(s,2,counters), prob, u0_dist, p, Koopman(), Tsit5())
x3_koop = expectation(s-&gt;g(s,3,counters), prob, u0_dist, p, Koopman(), Tsit5())
counters</code></pre><p>Leading to a total of <code>j sum(counters)</code> function evaluations.</p><p>Now, lets compare this to the vector-valued approach</p><pre><code class="language-julia hljs">function g(sol, counter)
    counter[1] = counter[1] + 1
    v = sol(4.0)[1]
    [v, v^2, v^3]
end

counter = [0]
expectation(s-&gt;g(s,counter), prob, u0_dist, p, Koopman(), Tsit5(); nout = 3)
counter</code></pre><p>This is <code>j round(counter[1]/sum(counters)*100,digits=2)</code>% the number of simulations required when using scalar-valued expectations. Note how the number of evaluations used in the vector-valued form is equivelent to the maximum number of evaluations for the 3 scalar-valued expectation calls.</p><h2 id="Higher-Order-Moments"><a class="docs-heading-anchor" href="#Higher-Order-Moments">Higher-Order Moments</a><a id="Higher-Order-Moments-1"></a><a class="docs-heading-anchor-permalink" href="#Higher-Order-Moments" title="Permalink"></a></h2><p>Leveraging this vector-valued capability, we can also efficiently compute higher-order central moments.</p><h3 id="Variance"><a class="docs-heading-anchor" href="#Variance">Variance</a><a id="Variance-1"></a><a class="docs-heading-anchor-permalink" href="#Variance" title="Permalink"></a></h3><p>The variance, or 2nd central moment, of a random variable <span>$X$</span> is defined as</p><p class="math-container">\[\mathrm{Var}\left(X\right)=\mathbb{E}\left[\left(X-\mu\right)^2\right]\]</p><p>where</p><p class="math-container">\[\mu = \mathbb{E}\left[X\right]\]</p><p>The expression for the variance can be expanded to</p><p class="math-container">\[\mathrm{Var}\left(X\right)=\mathbb{E}\left[X^2\right]-\mathbb{E}\left[X\right]^2\]</p><p>Using this, we define a function that returns the expectations of <span>$X$</span> and <span>$X^2$</span> as a vector-valued function and then compute the variance from these</p><pre><code class="language-julia hljs">function g(sol)
    x = sol(4.0)[1]
    [x, x^2]
end

koop = expectation(g, prob, u0_dist, p, Koopman(), Tsit5(); nout = 2)
mean_koop = koop[1]
var_koop = koop[2] - mean_koop^2</code></pre><p>For a linear system, we can propagate the variance analytically as</p><p class="math-container">\[e^{2pt}\mathrm{Var}\left(u_0\right)\]</p><pre><code class="language-julia hljs">exp(2*p[1]*4.0)*var(u0_dist[1])</code></pre><p>This can be computed at multiple time instances as well</p><pre><code class="language-julia hljs">saveat = tspan[1]:.5:tspan[2]
g(sol) = [Matrix(sol)&#39;; (Matrix(sol).^2)&#39;]

koop = expectation(g, prob, u0_dist, p, Koopman(), Tsit5(); nout = length(saveat)*2, saveat=saveat)
μ = koop.u[1:length(saveat)]
σ = sqrt.(koop.u[length(saveat)+1:end] - μ.^2)

plot(t-&gt;exp(p[1]*t)*mean(u0_dist[1]),tspan..., ribbon = t-&gt;-sqrt(exp(2*p[1]*t)*var(u0_dist[1])), label=&quot;Analytical Mean, 1 std bounds&quot;)
scatter!(collect(saveat),μ,marker=:x, yerror = σ, c=:black, label = &quot;Koopman Mean, 1 std bounds&quot;)</code></pre><h3 id="Skewness"><a class="docs-heading-anchor" href="#Skewness">Skewness</a><a id="Skewness-1"></a><a class="docs-heading-anchor-permalink" href="#Skewness" title="Permalink"></a></h3><p>A similar approach can be used to compute skewness</p><pre><code class="language-julia hljs">function g(sol)
    v = sol(4.0)[1]
    [v, v^2, v^3]
end

koop = expectation(g, prob, u0_dist, p, Koopman(), Tsit5(); nout = 3)
mean_koop = koop[1]
var_koop = koop[2] - mean_koop^2
(koop[3] - 3.0*mean_koop*var_koop - mean_koop^3) / var_koop^(3/2)</code></pre><p>As the system is linear, we expect the skewness to be unchanged from the inital distribution. Becasue the distribution is a truncated Normal distribution centered on the mean, the true skewness is <code>0.0</code>.</p><h3 id="nth-Central-Moment"><a class="docs-heading-anchor" href="#nth-Central-Moment">nth Central Moment</a><a id="nth-Central-Moment-1"></a><a class="docs-heading-anchor-permalink" href="#nth-Central-Moment" title="Permalink"></a></h3><p>SciMLExpectations provides a convenience function <code>centralmoment</code> around this approach for higher-order central moments. It takes an integer for the number of central moments you wish to compute. While the rest of the arguments are the same as for  <code>expectation()</code>. The following will return central moments 1-5.</p><pre><code class="language-julia hljs">g(sol) = sol(4.0)[1]
centralmoment(5, g, prob, u0_dist, p, Koopman(), Tsit5(),
                ireltol = 1e-9, iabstol = 1e-9)</code></pre><h2 id="Batch-Mode"><a class="docs-heading-anchor" href="#Batch-Mode">Batch-Mode</a><a id="Batch-Mode-1"></a><a class="docs-heading-anchor-permalink" href="#Batch-Mode" title="Permalink"></a></h2><p>It is also possible to solve the various simulations in parallel by using the <code>batch</code> kwarg and a batch-mode supported quadrature algorithm via the <code>quadalg</code> kwarg. To view the list of batch compatible quadrature algorithms, refer to <a href="https://github.com/SciML/Quadrature.jl">Quadrature.jl</a>. Note: Batch-mode operation is built on top of DifferentialEquation.jl&#39;s <code>EnsembleProblem</code>. See the <a href="https://diffeq.sciml.ai/stable/features/ensemble/">EnsembleProblem documentation</a> for additional options.</p><p>The default quadtrature algorithm used by <code>expectation()</code> does not support batch-mode evaluation. So, we first load dependencies for additional quadrature algorithms</p><pre><code class="language-julia hljs">using Quadrature, Cuba</code></pre><p>We then solve our expectation as before using a <code>batch=10</code> multi-thread parallelization via <code>EnsembleThreads()</code> of Cuba&#39;s SUAVE algorithm. However, in this case we introduce additional uncertainty in the model parameter.</p><pre><code class="language-julia hljs">u0_dist = [truncated(Normal(3.0,2.0),-5,11)]
p_dist = [truncated(Normal(-.7, .1), -1,0)]

g(sol) = sol(6.0)[1]

expectation(g, prob, u0_dist, p_dist, Koopman(), Tsit5(), EnsembleThreads();
                quadalg = CubaSUAVE(), batch=10)[1]</code></pre><p>Now, lets compare the performance of the batch and non-batch modes</p><pre><code class="language-julia hljs">using BenchmarkTools

@btime expectation(g, prob, u0_dist, p_dist, Koopman(), Tsit5();
                quadalg = CubaSUAVE())[1]</code></pre><pre><code class="language-julia hljs">@btime expectation(g, prob, u0_dist, p_dist, Koopman(), Tsit5(), EnsembleThreads();
                quadalg = CubaSUAVE(), batch=10)[1]</code></pre><p>It is also possible to parallelize across the GPU. However, one must be careful of the limitations of ensemble solutions with the GPU. Please refer to <a href="https://github.com/SciML/DiffEqGPU.jl">DiffEqGPU.jl</a> for details.</p><p>Here we load <code>DiffEqGPU</code> and modify our problem to use Float32 and to put the ODE in the required GPU form</p><pre><code class="language-julia hljs">using DiffEqGPU

function f(du, u,p,t)
    @inbounds begin
        du[1] = p[1]*u[1];
    end
    nothing
end

u0 = Float32[10.0]
p = Float32[-0.3]
tspan = (0.0f0,10.0f0)
prob = ODEProblem(f,u0,tspan,p)

g(sol) = sol(6.0)[1]

u0_dist = [truncated(Normal(3.0f0,2.0f0),-5f0,11f0)]
p_dist = [truncated(Normal(-.7f0, .1f0), -1f0,0f0)]

@btime expectation(g, prob, u0_dist, p_dist, Koopman(), Tsit5(), EnsembleGPUArray();
                   quadalg = CubaSUAVE(), batch=1000)[1]</code></pre><p>The performance gains realized by leveraging batch GPU processing is problem dependent. In this case, the number of batch evaluations required to overcome the overhead of using the GPU exceeds the number of simulations required to converge to the quadrature solution.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../optimization_under_uncertainty/">Optimization Under Uncertainty with SciMLExpectations.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Tuesday 6 September 2022 18:50">Tuesday 6 September 2022</span>. Using Julia version 1.8.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
