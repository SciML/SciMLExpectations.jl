<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Optimization Under Uncertainty · SciMLExpectations.jl</title><meta name="title" content="Optimization Under Uncertainty · SciMLExpectations.jl"/><meta property="og:title" content="Optimization Under Uncertainty · SciMLExpectations.jl"/><meta property="twitter:title" content="Optimization Under Uncertainty · SciMLExpectations.jl"/><meta name="description" content="Documentation for SciMLExpectations.jl."/><meta property="og:description" content="Documentation for SciMLExpectations.jl."/><meta property="twitter:description" content="Documentation for SciMLExpectations.jl."/><meta property="og:url" content="https://docs.sciml.ai/SciMLExpectations/stable/tutorials/optimization_under_uncertainty/"/><meta property="twitter:url" content="https://docs.sciml.ai/SciMLExpectations/stable/tutorials/optimization_under_uncertainty/"/><link rel="canonical" href="https://docs.sciml.ai/SciMLExpectations/stable/tutorials/optimization_under_uncertainty/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="SciMLExpectations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SciMLExpectations.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../introduction/">An Introduction to Expectations via SciMLExpectations.jl</a></li><li class="is-active"><a class="tocitem" href>Optimization Under Uncertainty</a><ul class="internal"><li><a class="tocitem" href="#System-Model"><span>System Model</span></a></li><li><a class="tocitem" href="#Considering-Uncertainty"><span>Considering Uncertainty</span></a></li><li><a class="tocitem" href="#Optimization-Under-Uncertainty"><span>Optimization Under Uncertainty</span></a></li><li><a class="tocitem" href="#Probabilistic-Constraints"><span>Probabilistic Constraints</span></a></li></ul></li><li><a class="tocitem" href="../gpu_bayesian/">GPU-Accelerated Data-Driven Bayesian Uncertainty Quantification with Koopman Operators</a></li><li><a class="tocitem" href="../process_noise/">Expectation of Process Noise</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/problem/">ExpectationProblem</a></li><li><a class="tocitem" href="../../manual/solve/">Solving Expectation Problems</a></li><li><a class="tocitem" href="../../manual/algorithms/">Expectation Algorithms</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Optimization Under Uncertainty</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Optimization Under Uncertainty</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/SciMLExpectations.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/SciMLExpectations.jl/blob/master/docs/src/tutorials/optimization_under_uncertainty.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="optimization_under_uncertainty"><a class="docs-heading-anchor" href="#optimization_under_uncertainty">Optimization Under Uncertainty</a><a id="optimization_under_uncertainty-1"></a><a class="docs-heading-anchor-permalink" href="#optimization_under_uncertainty" title="Permalink"></a></h1><p>This tutorial showcases how to leverage the efficient Koopman expectation method from SciMLExpectations to perform optimization under uncertainty. We demonstrate this by using a bouncing ball model with an uncertain model parameter. We also demonstrate its application to problems with probabilistic constraints, in particular a special class of constraints called chance constraints.</p><h2 id="System-Model"><a class="docs-heading-anchor" href="#System-Model">System Model</a><a id="System-Model-1"></a><a class="docs-heading-anchor-permalink" href="#System-Model" title="Permalink"></a></h2><p>First let&#39;s consider a 2D bouncing ball, where the states are the horizontal position <span>$x$</span>, horizontal velocity <span>$\dot{x}$</span>, vertical position <span>$y$</span>, and vertical velocity <span>$\dot{y}$</span>. This model has two system parameters, acceleration due to gravity and coefficient of restitution (models energy loss when the ball impacts the ground). We can simulate such a system using <code>ContinuousCallback</code> as</p><pre><code class="language-julia hljs">using DifferentialEquations, Plots

function ball!(du, u, p, t)
    du[1] = u[2]
    du[2] = 0.0
    du[3] = u[4]
    du[4] = -p[1]
end

ground_condition(u, t, integrator) = u[3]
ground_affect!(integrator) = integrator.u[4] = -integrator.p[2] * integrator.u[4]
ground_cb = ContinuousCallback(ground_condition, ground_affect!)

u0 = [0.0, 2.0, 50.0, 0.0]
tspan = (0.0, 50.0)
p = [9.807, 0.9]

prob = ODEProblem(ball!, u0, tspan, p)
sol = solve(prob, Tsit5(), callback = ground_cb)
plot(sol, vars = (1, 3), label = nothing, xlabel = &quot;x&quot;, ylabel = &quot;y&quot;)</code></pre><img src="1fadbcec.svg" alt="Example block output"/><p>For this particular problem, we wish to measure the impact distance from a point <span>$y=25$</span> on a wall at <span>$x=25$</span>. So, we introduce an additional callback that terminates the simulation on wall impact.</p><pre><code class="language-julia hljs">stop_condition(u, t, integrator) = u[1] - 25.0
stop_cb = ContinuousCallback(stop_condition, terminate!)
cbs = CallbackSet(ground_cb, stop_cb)

tspan = (0.0, 1500.0)
prob = ODEProblem(ball!, u0, tspan, p)
sol = solve(prob, Tsit5(), callback = cbs)
plot(sol, vars = (1, 3), label = nothing, xlabel = &quot;x&quot;, ylabel = &quot;y&quot;)</code></pre><img src="ff77107a.svg" alt="Example block output"/><p>To help visualize this problem, we plot as follows, where the star indicates a desired impact location</p><pre><code class="language-julia hljs">rectangle(xc, yc, w, h) = Shape(xc .+ [-w, w, w, -w] ./ 2.0, yc .+ [-h, -h, h, h] ./ 2.0)

begin
    plot(sol, vars = (1, 3), label = nothing, lw = 3, c = :black)
    xlabel!(&quot;x [m]&quot;)
    ylabel!(&quot;y [m]&quot;)
    plot!(rectangle(27.5, 25, 5, 50), c = :red, label = nothing)
    scatter!([25], [25], marker = :star, ms = 10, label = nothing, c = :green)
    ylims!(0.0, 50.0)
end</code></pre><img src="0fce94f6.svg" alt="Example block output"/><h2 id="Considering-Uncertainty"><a class="docs-heading-anchor" href="#Considering-Uncertainty">Considering Uncertainty</a><a id="Considering-Uncertainty-1"></a><a class="docs-heading-anchor-permalink" href="#Considering-Uncertainty" title="Permalink"></a></h2><p>We now wish to introduce uncertainty in <code>p[2]</code>, the coefficient of restitution. This is defined via a continuous univariate distribution from Distributions.jl. We can then run a Monte Carlo simulation of 100 trajectories via the <code>EnsembleProblem</code> interface.</p><pre><code class="language-julia hljs">using Distributions

cor_dist = truncated(Normal(0.9, 0.02), 0.9 - 3 * 0.02, 1.0)
trajectories = 100

prob_func(prob, i, repeat) = remake(prob, p = [p[1], rand(cor_dist)])
ensemble_prob = EnsembleProblem(prob, prob_func = prob_func)
ensemblesol = solve(ensemble_prob, Tsit5(), EnsembleThreads(), trajectories = trajectories,
    callback = cbs)

begin # plot
    plot(ensemblesol, vars = (1, 3), lw = 1)
    xlabel!(&quot;x [m]&quot;)
    ylabel!(&quot;y [m]&quot;)
    plot!(rectangle(27.5, 25, 5, 50), c = :red, label = nothing)
    scatter!([25], [25], marker = :star, ms = 10, label = nothing, c = :green)
    plot!(sol, vars = (1, 3), label = nothing, lw = 3, c = :black, ls = :dash)
    xlims!(0.0, 27.5)
end</code></pre><img src="37c1f679.svg" alt="Example block output"/><p>Here, we plot the first 350 Monte Carlo simulations along with the trajectory corresponding to the mean of the distribution (dashed line).</p><p>We now wish to compute the expected squared impact distance from the star. This is called an “observation” of our system or an “observable” of interest.</p><p>We define this observable as</p><pre><code class="language-julia hljs">obs(sol, p) = abs2(sol[3, end] - 25)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">obs (generic function with 1 method)</code></pre><p>With the observable defined, we can compute the expected squared miss distance from our Monte Carlo simulation results as</p><pre><code class="language-julia hljs">mean_ensemble = mean([obs(sol, p) for sol in ensemblesol])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">35.90267990627214</code></pre><p>Alternatively, we can use the <code>Koopman()</code> algorithm in SciMLExpectations.jl to compute this expectation much more efficiently as</p><pre><code class="language-julia hljs">using SciMLExpectations
gd = GenericDistribution(cor_dist)
h(x, u, p) = u, [p[1]; x[1]]
sm = SystemMap(prob, Tsit5(), callback = cbs)
exprob = ExpectationProblem(sm, obs, h, gd; nout = 1)
sol = solve(exprob, Koopman(), ireltol = 1e-5)
sol.u</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">36.00862821417056</code></pre><h2 id="Optimization-Under-Uncertainty"><a class="docs-heading-anchor" href="#Optimization-Under-Uncertainty">Optimization Under Uncertainty</a><a id="Optimization-Under-Uncertainty-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-Under-Uncertainty" title="Permalink"></a></h2><p>We now wish to optimize the initial position (<span>$x_0,y_0$</span>) and horizontal velocity (<span>$\dot{x}_0$</span>) of the system to minimize the expected squared miss distance from the star, where <span>$x_0\in\left[-100,0\right]$</span>, <span>$y_0\in\left[1,3\right]$</span>, and <span>$\dot{x}_0\in\left[10,50\right]$</span>. We will demonstrate this using a gradient-based optimization approach from NLopt.jl using <code>ForwardDiff.jl</code> AD through the expectation calculation.</p><pre><code class="language-julia hljs">using Optimization, OptimizationNLopt, OptimizationMOI
make_u0(θ) = [θ[1], θ[2], θ[3], 0.0]
function 𝔼_loss(θ, pars)
    prob = ODEProblem(ball!, make_u0(θ), tspan, p)
    sm = SystemMap(prob, Tsit5(), callback = cbs)
    exprob = ExpectationProblem(sm, obs, h, gd; nout = 1)
    sol = solve(exprob, Koopman(), ireltol = 1e-5)
    sol.u
end
opt_f = OptimizationFunction(𝔼_loss, Optimization.AutoForwardDiff())
opt_ini = [-1.0, 2.0, 50.0]
opt_lb = [-100.0, 1.0, 10.0]
opt_ub = [0.0, 3.0, 50.0]
opt_prob = OptimizationProblem(opt_f, opt_ini; lb = opt_lb, ub = opt_ub)
optimizer = OptimizationMOI.MOI.OptimizerWithAttributes(NLopt.Optimizer,
    &quot;algorithm&quot; =&gt; :LD_MMA)
opt_sol = solve(opt_prob, optimizer)
minx = opt_sol.u</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Float64}:
  0.0
  2.4428947026478425
 49.20927899180528</code></pre><p>Let&#39;s now visualize 100 Monte Carlo simulations</p><pre><code class="language-julia hljs">ensembleprob = EnsembleProblem(remake(prob, u0 = make_u0(minx)), prob_func = prob_func)
ensemblesol = solve(ensembleprob, Tsit5(), EnsembleThreads(), trajectories = 100,
    callback = cbs)

begin
    plot(ensemblesol, vars = (1, 3), lw = 1, alpha = 0.1)
    plot!(solve(remake(prob, u0 = make_u0(minx)), Tsit5(), callback = cbs),
        vars = (1, 3), label = nothing, c = :black, lw = 3, ls = :dash)
    xlabel!(&quot;x [m]&quot;)
    ylabel!(&quot;y [m]&quot;)
    plot!(rectangle(27.5, 25, 5, 50), c = :red, label = nothing)
    scatter!([25], [25], marker = :star, ms = 10, label = nothing, c = :green)
    ylims!(0.0, 50.0)
    xlims!(minx[1], 27.5)
end</code></pre><img src="a8e2c3d8.svg" alt="Example block output"/><p>Looks pretty good! But, how long did it take? Let&#39;s benchmark.</p><pre><code class="language-julia hljs">@time solve(opt_prob, optimizer)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">u: 3-element Vector{Float64}:
  0.0
  2.4428947026478425
 49.20927899180528</code></pre><p>Not bad for bound constrained optimization under uncertainty of a hybrid system!</p><h2 id="Probabilistic-Constraints"><a class="docs-heading-anchor" href="#Probabilistic-Constraints">Probabilistic Constraints</a><a id="Probabilistic-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Probabilistic-Constraints" title="Permalink"></a></h2><p>With this approach, we can also consider probabilistic constraints. Let us now consider a wall at <span>$x=20$</span> with height 25.</p><pre><code class="language-julia hljs">constraint = [20.0, 25.0]
begin
    plot(rectangle(27.5, 25, 5, 50), c = :red, label = nothing)
    xlabel!(&quot;x [m]&quot;)
    ylabel!(&quot;y [m]&quot;)
    plot!([constraint[1], constraint[1]], [0.0, constraint[2]], lw = 5, c = :black,
        label = nothing)
    scatter!([25], [25], marker = :star, ms = 10, label = nothing, c = :green)
    ylims!(0.0, 50.0)
    xlims!(minx[1], 27.5)
end</code></pre><img src="5bb9b590.svg" alt="Example block output"/><p>We now wish to minimize the same loss function as before, but introduce an inequality constraint such that the solution must have less than a 1% chance of colliding with the wall at <span>$x=20$</span>. This class of probabilistic constraints is called a chance constraint.</p><p>To do this, we first introduce a new callback and solve the system using the previous optimal solution</p><pre><code class="language-julia hljs">constraint_condition(u, t, integrator) = u[1] - constraint[1]
function constraint_affect!(integrator)
    integrator.u[3] &lt; constraint[2] ? terminate!(integrator) : nothing
end
constraint_cb = ContinuousCallback(constraint_condition, constraint_affect!,
    save_positions = (true, false));
constraint_cbs = CallbackSet(ground_cb, stop_cb, constraint_cb)

ensemblesol = solve(ensembleprob, Tsit5(), EnsembleThreads(), trajectories = 500,
    callback = constraint_cbs)

begin
    plot(ensemblesol, vars = (1, 3), lw = 1, alpha = 0.1)
    plot!(solve(remake(prob, u0 = make_u0(minx)), Tsit5(), callback = constraint_cbs),
        vars = (1, 3), label = nothing, c = :black, lw = 3, ls = :dash)

    xlabel!(&quot;x [m]&quot;)
    ylabel!(&quot;y [m]&quot;)
    plot!(rectangle(27.5, 25, 5, 50), c = :red, label = nothing)
    plot!([constraint[1], constraint[1]], [0.0, constraint[2]], lw = 5, c = :black)
    scatter!([25], [25], marker = :star, ms = 10, label = nothing, c = :green)
    ylims!(0.0, 50.0)
    xlims!(minx[1], 27.5)
end</code></pre><img src="2f69d1ee.svg" alt="Example block output"/><p>That doesn&#39;t look good!</p><p>We now need a second observable for the system. To compute a probability of impact, we use an indicator function for if a trajectory impacts the wall. In other words, this functions returns 1 if the trajectory hits the wall and 0 otherwise.</p><pre><code class="language-julia hljs">function constraint_obs(sol, p)
    sol((constraint[1] - sol[1, 1]) / sol[2, 1])[3] &lt;= constraint[2] ? one(sol[1, end]) :
    zero(sol[1, end])
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">constraint_obs (generic function with 1 method)</code></pre><p>Using the previously computed optimal initial conditions, let&#39;s compute the probability of hitting this wall</p><pre><code class="language-julia hljs">sm = SystemMap(remake(prob, u0 = make_u0(minx)), Tsit5(), callback = cbs)
exprob = ExpectationProblem(sm, constraint_obs, h, gd; nout = 1)
sol = solve(exprob, Koopman(), ireltol = 1e-5)
sol.u</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.9988981583360147</code></pre><p>We then set up the constraint function for NLopt just as before.</p><pre><code class="language-julia hljs">function 𝔼_constraint(res, θ, pars)
    prob = ODEProblem(ball!, make_u0(θ), tspan, p)
    sm = SystemMap(prob, Tsit5(), callback = cbs)
    exprob = ExpectationProblem(sm, constraint_obs, h, gd; nout = 1)
    sol = solve(exprob, Koopman(), ireltol = 1e-5)
    res .= sol.u
end
opt_lcons = [-Inf]
opt_ucons = [0.01]
optimizer = OptimizationMOI.MOI.OptimizerWithAttributes(NLopt.Optimizer,
    &quot;algorithm&quot; =&gt; :LD_MMA)
opt_f = OptimizationFunction(𝔼_loss, Optimization.AutoForwardDiff(), cons = 𝔼_constraint)
opt_prob = OptimizationProblem(opt_f, opt_ini; lb = opt_lb, ub = opt_ub, lcons = opt_lcons,
    ucons = opt_ucons)
opt_sol = solve(opt_prob, optimizer)
minx2 = opt_sol.u</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Float64}:
 -0.8933087495240182
  2.0005561486807566
 50.0</code></pre><p>The probability of impacting the wall is now</p><pre><code class="language-julia hljs">container = zeros(1)
𝔼_constraint(container, minx2, nothing)
λ = container[1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.0024804394521740487</code></pre><p>We can check if this is within tolerance by</p><pre><code class="language-julia hljs">λ &lt;= 0.01 + 1e-5</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Again, we plot some Monte Carlo simulations from this result as follows</p><pre><code class="language-julia hljs">ensembleprob = EnsembleProblem(remake(prob, u0 = make_u0(minx2)), prob_func = prob_func)
ensemblesol = solve(ensembleprob, Tsit5(), EnsembleThreads(),
    trajectories = 500, callback = constraint_cbs)

begin
    plot(ensemblesol, vars = (1, 3), lw = 1, alpha = 0.1)
    plot!(solve(remake(prob, u0 = make_u0(minx2)), Tsit5(), callback = constraint_cbs),
        vars = (1, 3), label = nothing, c = :black, lw = 3, ls = :dash)
    plot!([constraint[1], constraint[1]], [0.0, constraint[2]], lw = 5, c = :black)

    xlabel!(&quot;x [m]&quot;)
    ylabel!(&quot;y [m]&quot;)
    plot!(rectangle(27.5, 25, 5, 50), c = :red, label = nothing)
    scatter!([25], [25], marker = :star, ms = 10, label = nothing, c = :green)
    ylims!(0.0, 50.0)
    xlims!(minx[1], 27.5)
end</code></pre><img src="da87d0ef.svg" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../introduction/">« An Introduction to Expectations via SciMLExpectations.jl</a><a class="docs-footer-nextpage" href="../gpu_bayesian/">GPU-Accelerated Data-Driven Bayesian Uncertainty Quantification with Koopman Operators »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.0 on <span class="colophon-date" title="Sunday 1 October 2023 15:12">Sunday 1 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
